# This source file defines the microcode for the 74xx Computer.
# The file is to be compiled with mcc.exe which results in a binary that is then uploaded to the microcode ROM.
#
# File layout:
# - The first part (header) of the file defines all the mnemonics, opcodes and control lines.
# - The second part (code) of the file defines the microcode.
#
# Header syntax:
# ---------------
#
# INSTRUCTIONS
# {
# 	<MNEMONIC>(<LENGTH>):<OPCODE>;<MNEMONIC>(<LENGTH>):<OPCODE>;<MNEMONIC>(<LENGTH>):<OPCODE>
#   length = number of bytes used by instruction (e.g. MOV A B has no operands and is just 1 byte, JMP 0x1 0x2 has two operands and uses 3 bytes)
# }
#
# CONTROLLINES
# {
# 	<CONTROLLINE_NAME>;<CONTROLLINE_NAME> 
#	(repeat for all 48 control lines in correct bit order)
# }
#
# - Opcode is a binary value (LSBF)
# - Newlines and additional spaces around the ; are ignored
# - Control line name is "NC" for unused lines
# - T-states 0 & 1 (instruction fetch) are hard-wired and do not need to be defined in microcode
#
# Code syntax:
#----------------
#
# MICROCODE
# {
# 	<MNEMONIC>
# 	{
# 		<T-STATE>
#		{
#			[flags_state] CONTROLLINE_NAME;CONTROLLINE_NAME
#		}
# 	}
# 	<MNEMONIC> (r1) (r2)
# 	{
# 		<T-STATE>
#		{
#			[flags_state] CONTROLLINE_NAME_(r1);CONTROLLINE_NAME_(r2)
#		}
# 	}
# }
#
# - Flags state is binary and order as such: Fgt, Feq, Flt, Fz, Fc.
# - Use 'x' in flag state to act on any state of that bit.
# - If flags state is irrelevant (xxxxx) it may be ommited.
#   So "0 { TSTATE_reset }" would be a valid t-state definition.
# - (r1) and (r2) may be used to indicate registers.
#   The compiler will automatically try to compile the instruction against all registers, 
#   as long as the instruction (e.g. MOV B D) exists in the instructions list
#

INSTRUCTIONS
{
	NOP(1):0000000;
	HALT(1):0000001;
	MOV A B(1):0000010;
	MOV A C(1):0000011;
	MOV A D(1):0000100;
	MOV B A(1):0000101;
	MOV B C(1):0000110;
	MOV B D(1):0000111;
	MOV C A(1):0001000;
	MOV C B(1):0001001;
	MOV C D(1):0001010;
	MOV D A(1):0001011;
	MOV D B(1):0001100;
	MOV D C(1):0001101;
	MVI A(2):0001110;
	MVI B(2):0001111;
	MVI C(2):0010000;
	MVI D(2):0010001;
	LD A(3):0010010;
	LD B(3):0010011;
	ST A(3):0010110;
	ST B(3):0010111;
	ADD A(1):0011010;
	ADD B(1):1100001;
	ADD C(1):0011011;
	ADD D(1):0011100;
	ADC A(1):0011101;
	ADC B(1):1100010;
	ADC C(1):0011110;
	ADC D(1):0011111;
	SUB A(1):0100000;
	SUB B(1):1100011;
	SUB C(1):0100001;
	SUB D(1):0100010;
	SBC A(1):0100011;
	SBC B(1):1100100;
	SBC C(1):0100100;
	SBC D(1):0100101;
	AND A(1):0100110;
	AND B(1):1100101;
	AND C(1):0100111;
	AND D(1):0101000;
	OR A(1):0101001;
	OR B(1):1100110;
	OR C(1):0101010;
	OR D(1):0101011;
	XOR A(1):0101100;
	XOR B(1):0101101;
	XOR C(1):0101110;
	XOR D(1):0101111;
	NOT A(1):0110000;
	NOT B(1):0110001;
	NOT C(1):0110010;
	NOT D(1):0110011;
	INC A(1):0110100;
	INC B(1):0110101;
	INC C(1):0110110;
	INC D(1):0110111;
	DEC A(1):0111000;
	DEC B(1):0111001;
	DEC C(1):0111010;
	DEC D(1):0111011;
	CMP(1):0111100;
	JMP(3):0111111;
	JZ(3):1000000;
	JNZ(3):1000001;
	JC(3):1000010;
	JNC(3):1000011;
	JEQ(3):1000100;
	JLT(3):1000101;
	JGT(3):1000110;
	CALL(3):1000111;
	RET(1):1001000;
	IN A(1):1001001;
	IN B(1):1001010;
	IN C(1):1001011;
	IN D(1):1001100;
	OUT 1 A(1):1001101;
	OUT 1 B(1):1001110;
	OUT 1 C(1):1001111;
	OUT 1 D(1):1010000;
	OUT 2 A(1):1010001;
	OUT 2 B(1):1010010;
	OUT 2 C(1):1010011;
	OUT 2 D(1):1010100;
	MOV A AX(1):1010101;
	MOV B AX(1):1010110;
	MOV C AX(1):1010111;
	MOV D AX(1):1011000;
	MOV A AY(1):1011001;
	MOV B AY(1):1011010;
	MOV C AY(1):1011011;
	MOV D AY(1):1011100;
	MVI AX(2):0111101;
	MVI AY(2):0111110;
	SHL A(1):0010100;
	SHL B(1):0010101;
	SHL C(1):0011000;
	SHL D(1):0011001;
	SHR A(1):1011101;
	SHR B(1):1011110;
	SHR C(1):1011111;
	SHR D(1):1100111;
	SC 0(1):1101000;
	SC 1(1):1101001;
	LD AX(3):1101010;
	LD AY(3):1101011;
	JNE(3):1101100;
}

CONTROLLINES
{
	NC;				NC;			NC;			FLAGS_Fc_set;	FLAGS_Fc_clear;	FLAGS_Fc_load;	FLAGS_Flt_load;	FLAGS_Feq_load;
	FLAGS_Fgt_load;	OUT2_load;	OUT1_load;	IN_out;			TSTATE_reset;	CLOCK_halt;		MEM_out;		MEM_RAM_load;
	MAR_STK_load;	MAR_PC_load;MAR_HB_load;MAR_LB_load;	ALU_out;		ALU_shr;		ALU_m;			ALU_s3;
	ALU_s2;			ALU_s1;		ALU_s0;		AY_load;		AX_load;		STK_reset;		STK_dec;		STK_inc;
	PC_HB_out;		PC_LB_out;	PC_HB_load;	PC_LB_load;		PC_dec;			PC_inc;			IR_load;		FLAGS_Fz_load;
	D_load;			D_out;		C_load;		C_out;			B_load;			B_out;			A_load;			A_out;
}

MICROCODE
{
	NOP {
		0 { TSTATE_reset }
	}

	HALT {
		0 { CLOCK_halt }
	}

	MOV (r1) (r2) {
		0 { (r1)_out;(r2)_load }
		1 { TSTATE_reset }
	}

	MVI (r1) {
		0 { MAR_PC_load	}
		1 { MEM_out;(r1)_load;PC_inc }
		2 { TSTATE_reset }
	}

	LD (r1) {
		0 { MAR_PC_load }
		1 { MEM_out;D_load;PC_inc }
		2 { MAR_PC_load	}
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;MAR_LB_load }
		5 { D_out;MAR_HB_load }
		6 { MEM_out;(r1)_load }
		7 { TSTATE_reset }
	}

	ST (r1) {
		0 { MAR_PC_load }
		1 { MEM_out;D_load;PC_inc }
		2 { MAR_PC_load }
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;MAR_LB_load }
		5 { D_out;MAR_HB_load }
		6 { (r1)_out;MEM_RAM_load }
		7 { TSTATE_reset }
	}

	ADD (r1) {
		0 { FLAGS_Fc_clear }
		1 { ALU_s0;ALU_s3;ALU_out;(r1)_load;FLAGS_Fc_load;FLAGS_Fz_load }
		2 { TSTATE_reset }
	}

	ADC (r1) {
		0 { ALU_s0;ALU_s3;ALU_out;(r1)_load }
		1 { ALU_s0;ALU_s3;FLAGS_Fc_load;FLAGS_Fz_load }
		2 { TSTATE_reset }
	}

	SUB (r1) {
		0 { FLAGS_Fc_set }
		1 { ALU_s1;ALU_s2;ALU_out;(r1)_load;FLAGS_Fc_load;FLAGS_Fz_load }
		2 { TSTATE_reset }
	}

	SBC (r1) {
		0 { ALU_s1;ALU_s2;ALU_out;(r1)_load }
		1 { ALU_s1;ALU_s2;ALU_out;FLAGS_Fc_load;FLAGS_Fz_load }
		2 { TSTATE_reset }
	}

	AND (r1) {
		0 { ALU_s0;ALU_s1;ALU_s3;ALU_m;ALU_out;(r1)_load }
		1 { TSTATE_reset }
	}

	OR (r1) {
		0 { FLAGS_Fc_clear;ALU_s0;ALU_out;(r1)_load }
		1 { TSTATE_reset }
	}

	XOR (r1) {
		0 { FLAGS_Fc_clear;ALU_s1;ALU_s2;ALU_m;ALU_out;(r1)_load }
		1 { TSTATE_reset }
	}

	INC (r1) {
		0 { FLAGS_Fc_set }
		1 { ALU_out;(r1)_load;FLAGS_Fc_load;FLAGS_Fz_load }
		2 { TSTATE_reset }
	}

	DEC (r1) {
		0 { FLAGS_Fc_clear;ALU_s0;ALU_s1;ALU_s2;ALU_s3;ALU_out;(r1)_load;FLAGS_Fc_load;FLAGS_Fz_load }
		1 { TSTATE_reset }
	}

# Set zero flag
	SHL (r1) {
		0 { FLAGS_Fc_clear;ALU_s2;ALU_s3;ALU_out;(r1)_load }
		1 { TSTATE_reset }
	}

# Set zero flag
	SHR (r1) {
		0 { ALU_shr;(r1)_load;FLAGS_Fc_load;FLAGS_Fz_load }
		1 { TSTATE_reset }
	}

	NOT (r1) {
		0 { ALU_m;ALU_out;(r1)_load }
		1 { TSTATE_reset }
	}

	SC 0 {
		0 { FLAGS_Fc_clear }
		1 { TSTATE_reset }
	}

	SC 1 {
		0 { FLAGS_Fc_set }
		1 { TSTATE_reset }
	}

	CALL {
		0 { PC_inc }
		1 { PC_inc }
		2 { PC_LB_out;C_load }
		3 { PC_HB_out;D_load }
		4 { MAR_STK_load;D_out;MEM_RAM_load;STK_inc;PC_dec }
		5 { MAR_STK_load }
		6 { C_out;MEM_RAM_load;STK_inc;PC_dec }
		7 { MAR_PC_load }
		8 { MEM_out;D_load;PC_inc }
		9 { MAR_PC_load }
		10 { MEM_out;C_load;PC_inc }
		11 { D_out;PC_HB_load }
		12 { C_out;PC_LB_load }
	}

	RET {
		0 { STK_dec }
		1 { MAR_STK_load }
		2 { MEM_out;C_load;STK_dec }
		3 { MAR_STK_load }
		4 { MEM_out;D_load }
		5 { C_out;PC_LB_load }
		6 { D_out;PC_HB_load }
		7 { TSTATE_reset }
	}

	JMP {
		0 { MAR_PC_load }
		1 { MEM_out;D_load;PC_inc }
		2 { MAR_PC_load }
		3 { MEM_out;C_load }
		4 { C_out;PC_LB_load }
		5 { D_out;PC_HB_load }
		6 { TSTATE_reset }
	}

	JZ {
		0 {
			[xxx0x] PC_inc
			[xxx1x] MAR_PC_load
		}
		1 { 
			[xxx0x] PC_inc
			[xxx1x] MEM_out;D_load;PC_inc 
		}
		2 { 
			[x0x0x] TSTATE_reset
			[xxx1x] MAR_PC_load	
		}
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;PC_LB_load }
		5 { D_out;PC_HB_load }
		6 { TSTATE_reset }
	}

	JNZ {
		0 {
			[xxx1x] PC_inc
			[xxx0x] MAR_PC_load
		}
		1 { 
			[xxx1x] PC_inc
			[xxx0x] MEM_out;D_load;PC_inc 
		}
		2 { 
			[x0x1x] TSTATE_reset
			[xxx0x] MAR_PC_load	
		}
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;PC_LB_load }
		5 { D_out;PC_HB_load }
		6 { TSTATE_reset }
	}

	JEQ {
		0 {
			[x0xxx] PC_inc
			[x1xxx] MAR_PC_load
		}
		1 { 
			[x0xxx] PC_inc
			[x1xxx] MEM_out;D_load;PC_inc 
		}
		2 { 
			[x0xxx] TSTATE_reset
			[x1xxx] MAR_PC_load	
		}
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;PC_LB_load }
		5 { D_out;PC_HB_load }
		6 { TSTATE_reset }
	}

	JNE {
		0 {
			[x1xxx] PC_inc
			[x0xxx] MAR_PC_load
		}
		1 { 
			[x1xxx] PC_inc
			[x0xxx] MEM_out;D_load;PC_inc 
		}
		2 { 
			[x1xxx] TSTATE_reset
			[x0xxx] MAR_PC_load	
		}
		3 { MEM_out;C_load;PC_inc }
		4 { C_out;PC_LB_load }
		5 { D_out;PC_HB_load }
		6 { TSTATE_reset }
	}

	CMP {
		1 { FLAGS_Fc_clear;ALU_s1;ALU_s2;FLAGS_Feq_load;FLAGS_Fgt_load }
		2 { FLAGS_Fc_set }
		3 { ALU_s1;ALU_s2;FLAGS_Flt_load }
		4 { TSTATE_reset }
	}
}
